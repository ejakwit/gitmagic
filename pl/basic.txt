== Podstawowe triki ==

Zamiast zgłębiać ogrom komend Gita możesz użyć tych podstawowych przedstawionych w tym rozdziale co umożliwi Ci szybkie osiągnięcie celu. Pomimo swojej prostoty, każda z nich jest użyteczna.  
Co więcej, w trakcie pierwszych miesięcy korzystania z Gita, nigdy nie potrzebowałem wiedzy spoza tego rozdziału.

=== Zapisywanie stanu ===

Chcesz wprowadzić ryzykowną zmianę? Zanim to zrobisz, użyj poniższych komend żeby zapisać stan wszystkich plików w aktualnym folderze:

 $ git init
 $ git add .
 $ git commit -m "Mój pierwszy backup"

Jeśli wprowadzisz złe zmiany, możesz odzyskać poprzednie wersję za pomocą komendy:

 $ git reset --hard

Aby ponownie zapisać stan zmienionych plików:

 $ git commit -a -m "Kolejny backup"

=== Dodawanie, usuwanie, zmiana nazwy ===

Powyższe komendy śledzą zmiany w plikach które były dostępne, gdy pierwszy raz wykonano komendę *git add*. Jeśli dodasz nowe pliki albo podkatalogi, wtedy musisz poinformować o tym Gita:

 $ git add readme.txt Documentation

Analogicznie, jeśli chcesz aby Git zapomniał o plikach:

 $ git rm kludge.h obsolete.c
 $ git rm -r incriminating/evidence/

Git skasuje za Ciebie te pliki, jeśli jeszcze je tam znajdzie.

Zmiana nazwy pliku polega na usunięciu starej nazwy i dodaniu nowej. Istnieje skrót *git mv* posiadający taką samą składnię jak komenda *mv*. Na przykład:

 $ git mv bug.c feature.c

=== Zaawansowane Cofnij/Powtórz ===

Czasami chcesz po prostu wrócić i zapomnieć o każdej zmianie od pewnego punktu w czasie, ponieważ wszystkie późniejsze zmiany były błędne. W takiej sytuacji:

 $ git log

pokazuje listę ostatnich wprowadzonych zmian oraz ich sum kontrolnych SHA1:

----------------------------------
commit 766f9881690d240ba334153047649b8b8f11c664
Author: Bob <bob@example.com>
Date:   Tue Mar 14 01:59:26 2000 -0800

    Replace printf() with write().

commit 82f5ea346a2e651544956a8653c0f58dc151275c
Author: Alice <alice@example.com>
Date:   Thu Jan 1 00:00:00 1970 +0000

    Initial commit.
----------------------------------

Pierwsze kilka znaków sumy kontrolnej jest wystarczające do określenia zmiany; ewentualnie, możesz skopiować i wkleić całą sumę kontrolną. Wpisz:

 $ git reset --hard 766f

aby przywrócić stan z określonego punktu czasowego i trwale usunąć informacje o wszystkich wprowadzonych później zmianach.

Jeśli chcesz tymczasowo powrócić do poprzedniego stany, wpisz:

 $ git checkout 82f5

Ta komenda cofnie Cię w czasie, jednocześnie zachowując nowsze wersje. Podobnie jak w przypadku podróży w czasie, jeśli dokonasz zmian na przeszłej wersji a następnie zapiszesz wersję w repozytorium przy pomocy komendy commit znajdziesz się w alternatywnej rzeczywistości, ponieważ twoje akcje są inne niż gdy wykonywałeś je za pierwszym razem. 

Tą alternatywną rzeczywistość nazywamy 'gałęzią' (ang. branch) i <<branch, omówimy dokładnie w dalszej części>>. W tym momencie, zapamiętaj że: 

 $ git checkout master

przeniesię Cię z powrotem do teraźniejszości. Aby uniknąć narzekań Gita, zawsze wykonaj commit lub reset na swoich zmianach zanim wykonasz checkout. 

Wracając do analogii z grami komputerowymi:

- *`git reset --hard`*: otwiera starszy stan gry i kasuje wszystkie zapisane stany gry nowsze niż właśnie załadowany

- *`git checkout`*:  otwiera starszy stan gry, ale jeśli będziesz na nim grał, to stan gry będzie różnił się od nowszych stanów gry zapisanych, gdy grałeś po raz pierwszy. W związku z tym, nowe stany gry będą zapisywane na osobnej gałęzi reprezentującej alternatywną rzeczywistość do której wkroczyłeś. <<branch,Omówimy to w dalszej części>>. 

Możesz otworzyć jedynie wybrane pliki i podkatalogi poprzez dopisanie ich na końcu komendy:

 $ git checkout 82f5 jakis.plik jakis_inny.plik

Bądź ostrożny, ponieważ ta postać komendy *checkout* może po cichu nadpisać pliki. Aby nie utracić zmian, wywołaj komendę commit przed wywowałeniem checkou checkout, zwłaszcza jeśli uczysz się Gita. Ogólnie, jeśli masz wątpliwości czy wykonać daną komendę, uruchom najpierw *git commit -a*. 

Jeśli nie lubisz kopiowania i wklejania sum kontrolnych, użyj komendy: 

 $ git checkout :/"Mój pierwszy b"

aby przeskoczyć do wersji zaczynającej się od podanego tekstu.
Możesz również odtworzyć 5-tą zapisanę wersję:

 $ git checkout master~5

=== Przywracanie (revert) ===

Zdarzenie w sądzie mogą zostać wyłączone z protokołu. Podobnie w Gicie, możesz wycofać wybranę operacje commit. Komenda:

 $ git commit -a
 $ git revert 1b6d

wycofa tylko commit określony przez podaną sumę kontrolną. Wycofanie wersji zostanie zapisane jako kolejna operacja commit, co możesz sprawdzić poprzez wykonanie komendy *git log*.

=== Changelog Generation ===

Some projects require a http://en.wikipedia.org/wiki/Changelog[changelog].
Generate one by typing:

 $ git log > ChangeLog

=== Downloading Files ===

Get a copy of a project managed with Git by typing:

 $ git clone git://server/path/to/files

For example, to get all the files I used to create this site:

 $ git clone git://git.or.cz/gitmagic.git

We'll have much to say about the *clone* command soon.

=== The Bleeding Edge ===

If you've already downloaded a copy of a project using *git clone*, you can upgrade to the latest version with:

 $ git pull

=== Instant Publishing ===

Suppose you've written a script you'd like to share with others. You could just tell them to download from your computer, but if they do so while you're improving the script or making experimental changes, they could wind up in trouble.  Of course, this is why release cycles exist. Developers may work on a project frequently, but they only make the code available when they feel it is presentable.

To do this with Git, in the directory where your script resides:

 $ git init
 $ git add .
 $ git commit -m "First release"

Then tell your users to run:

 $ git clone your.computer:/path/to/script

to download your script. This assumes they have ssh access. If not, run *git daemon* and tell your users to instead run:

 $ git clone git://your.computer/path/to/script

From now on, every time your script is ready for release, execute:

 $ git commit -a -m "Next release"

and your users can upgrade their version by changing to the directory containing your script and typing:

 $ git pull

Your users will never end up with a version of your script you don't want them to see.

=== What Have I Done? ===

Find out what changes you've made since the last commit with:

 $ git diff

Or since yesterday:

 $ git diff "@{yesterday}"

Or between a particular version and 2 versions ago:

 $ git diff 1b6d "master~2"

In each case the output is a patch that can be applied with *git apply*.
Try also:

 $ git whatchanged --since="2 weeks ago"

Often I'll browse history with http://sourceforge.net/projects/qgit[qgit] instead, due to its slick photogenic interface, or http://jonas.nitro.dk/tig/[tig], a text-mode interface that works well over slow connections. Alternatively, install a web server, run *git instaweb* and fire up any web browser.

=== Exercise ===

Let A, B, C, D be four successive commits where B is the same as A except some files have been removed. We want to add the files back at D. How can we do this?

There are at least three solutions. Assuming we are at D:

  1. The difference between A and B are the removed files. We can create a patch representing this difference and apply it:

   $ git diff B A | git apply

  2. Since we saved the files back at A, we can retrieve them:

   $ git checkout A foo.c bar.h

  3. We can view going from A to B as a change we want to undo:

   $ git revert B

Which choice is best? Whichever you prefer most. It is easy to get what you want with Git, and often there are many ways to get it.
