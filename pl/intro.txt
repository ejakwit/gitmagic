== Wstęp ==

Posłużę się analogią do wyjaśnienia czym jest system kontroli wersji. Bardziej sformalizowaną definicję znajdziesz na http://pl.wikipedia.org/wiki/System_kontroli_wersji[stronie Wikipedii poświęconej systemom kontroli wersji]. 

=== Praca jako gra ===

Grałem w gry komputerowe przez prawie całe swoje życie. W przeciwieństwie do tego, systemów kontroli wersji zacząłem używać jako dorosły. Podejrzewam, że nie jestem w tym osamotniony, a w związku z tym, porównanie tych dwóch konceptów sprawi, że wyjaśnienie i zrozumienie ich stanie się prostsze.

Pomyśl o edycji kodu, lub dokumentu, jak o graniu w grę komputerową. Po dokonaniu wielu zmian, chciałbyś zapisać efekty pracy. Aby to uczynisz, klikasz 'Zapisz' w swoim edytorze.

Taka operacja nadpisze starą wersję. Przypomina to stare gry komputerowe, w których możliwy był zapis tylko jednego stanu gry: oczywiście zapis taki był możliwy, ale nie można było załadować stanu innego niż ostatnio zapisany. Wielka szkoda, ponieważ starszy stan gry mógł odpowiadać wyjątkowo interesującemu fragmentowi gry do którego chciałbyś któregoś dnia powrócić. Albo co gorsza, twój obecnie zapisany stan gry uniemożliwia dokończenie gry i będziesz musiał zacząć grę od początku.  

=== Kontrola wersji ===

W trakcie edycji, możesz użyć opcji 'Zapisz jako' inny plik, albo skopiować plik do innej lokalizacji przed wykonaniem operacji 'Zapisz' po to aby ocalić starszą wersję. Może również kompresować poprzednie wersje, aby zaoszczędzić przestrzeni. Jest to prymitywna i czasochłonna forma kontroli wersji. Gry komputerowe usprawniły ten proces dawno temu, poprzez umożliwienie zapisania wielu stanów gry powiązanych z informacją o czasie wykonania operacji. 

Rozważmy bardziej skomplikowany przypadek. Wyobraźmy sobie, że mamy zestaw plików które muszą ze sobą współdziałać, np. kod źródłowy projektu albo pliki strony internetowej. W tej sytuacji, gdybyś chciał zachować starszą wersję musiałbyś zarchiwizować cały katalog. Przechowywanie wielu wersji staje się niewygodne i szybko zaczyna być kosztowne.

W niektórych grach, zapisany stan zawiera katalog pełen plików. Takie gry ukrywają szczegóły przed graczem i udostępniają wygodny interfejs do zarządzania różnymi wersjami tego katalogu.

Systemy kontroli wersji działają tak samo. Wszystkie mają wygodne interfejsy służące do zarządzania katalogiem zawierającym różne rzeczy. Możesz często zapisywać stan katalogu, a w razie potrzeby masz możliwość odtworzenia dowolnego stanu z przeszłości. W przeciwieństwie do większości gier, systemy kontroli wersji są sprytne w zakresie oszczędzania przestrzeni. Zwykle, tylko kilka plików uległo zmianom pomiędzy wersjami a ich charakter jest drobny. Przechowywanie informacji o różnicach pomiędzy plikami zamiast kopiowania plików pozwala zaoszczędzić przestrzeń. 

=== Rozproszona kontrola ===

A teraz, wyobraź sobie bardzo trudną grę komputerową. Tak trudną do ukończenia, że aby ją ukończyć wielu doświadczonych graczy z całego świata zdecydowało połączyć siły i współdzielić swoje zapisane stany gry, po to aby wspólnie ukończyć grę. Speedruny są przykładem ze świata rzeczywistego: gracze specjalizujący się w graniu na poszczególnych etapach tej samej gry współpracują, aby osiągnąć zadziwiające rezultaty. 

Jak skonstruować system umożliwiający łatwy dostęp do zapisanych stanów gry innych osób oraz ładowanie nowych stanów gry?

W dawnych czasach, każdy projekt używał scentralizowanej kontroli wersji. Jedynie zdalny serwer przechowywał wszystkie zapisane gry. Poza tym, każdy gracz przechowywał co najwyżej kilka stanów gry na swojej maszynie. Gdy któryś z graczy chciał przejść kolejny etap gry, musiał on pobrać ostatni stan z serwera głównego, pograć chwilę, zapisać stan a następnie wysłać go na serwer główny tak, żeby inni mogli z niego skorzystać.  

Co jeśli gracz, z jakiegoś powodu, chciałby odzyskać starszy stan gry? Być może obecnie przechowywane stany gry uniemożliwiają ukończenie gry ponieważ ktoś zapomniał wcześniej zebrać przedmiot na poziomie trzecim. W takiej sytuacji, gracze chcieliby odnaleźć najmniej odległy w czasie stan gry w którym jej ukończenie jest jeszcze możliwe. Być może, gracze chcieliby porównać dwa starsze stany gry, aby zobaczyć ile pracy wykonały każdy z graczy. 

Możemy wyobrazić sobie wiele powodów dla których chcielibyśmy powrócić do starszej rewizji, ale (w przypadku systemu scentralizowanego) rezultat będzie zawsze taki sam. Musielibyśmy połączyć się z serwerem centralnym, aby pobrać starszą wersję stany gry. Im więcej wersji byśmy potrzebowali, tym więcej komunikacji sieciowej byłoby wymagane. 

Systemy kontroli wersji nowej generacji, do których zalicza się Git, nazywamy systemami rozproszonymi i możemy traktować je jako uogólnienie systemów zcentralizowanych. Gdy gracze pobierają pliki z serwera głównego otrzymują oni wszystkie zapisane do tej pory wersje - nie jedynie najnowsze. W ten sposób, ich komputery stają się serwerami lustrzanymi serwera głównego. 

Taka wstępna operacja klonowania może być kosztowna, szczególnie jeśli historia zmian jest rozbudowana. Mimo tego jest to podejście opłacalne w dłuższej perspektywie czasowej. Oczywistą korzyścią takiego rozwiązania jest zapewnienie dostępu do starszych rewizji bez konieczności komunikowania się z serwerem głównym.

=== Nieuzasadniony przesąd ===

Zgodnie z popularnym nieporozumieniem, systemy rozproszonę nie pasują do projektów wymagających oficjalnego repozytorium centralnego. Nic bardziej mylnego. 
Robienie komuś zdjęć nie kradnie ich dusz. Analogicznie, klonowanie repozytorium głównego nie pomniejsza jego ważności.



A good first approximation is that anything a centralized version control system can do, a well-designed distributed system can do better. Network resources are simply costlier than local resources. While we shall later see there are drawbacks to a distributed approach, one is less likely to make erroneous comparisons with this rule of thumb.

A small project may only need a fraction of the features offered by such a
system, but using systems that scale poorly for tiny projects is like using
Roman numerals for calculations involving small numbers.

Moreover, your project may grow beyond your original expectations. Using Git from the outset is like carrying a Swiss army knife even though you mostly use it to open bottles. On the day you desperately need a screwdriver you'll be glad you have more than a plain bottle-opener.

=== Merge Conflicts ===

For this topic, our computer game analogy becomes too thinly stretched. Instead, let us again consider editing a document.

Suppose Alice inserts a line at the beginning of a file, and Bob appends one at the end of his copy. They both upload their changes. Most systems will automatically deduce a reasonable course of action: accept and merge their changes, so both Alice's and Bob's edits are applied.

Now suppose both Alice and Bob have made distinct edits to the same line. Then it is impossible to proceed without human intervention. The second person to upload is informed of a _merge conflict_, and must choose one edit over another, or revise the line entirely.

More complex situations can arise. Version control systems handle the simpler cases themselves, and leave the difficult cases for humans. Usually their behaviour is configurable.
